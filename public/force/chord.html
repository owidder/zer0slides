<style>

    #__0__ path.group {
        stroke: black;
    }

</style>

<div class="graph"></div>

<script>

    (function () {
        const d3 = _0.d3;
        const _ = _0._;

        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select("#__0__ .graph").append("svg")
            .attr("width", width)
            .attr("height", height);

        const svgG = svg.append("g");
        const rootG = svgG.append("g");
        let groupG;
        let tickG;
        let chordG;

        function reset() {
            rootG.selectAll("g").remove();
            groupG = rootG.append("g");
            tickG = rootG.append("g");
            chordG = rootG.append("g").attr("class", "chord");
        }

        const color = d3.scaleOrdinal(d3.schemeCategory10);

        function redrawChord(data, duration) {

            svgG.transition()
                .duration(duration)
                .attr("transform", "translate(" + width / 2 + "," + ((height / 2) + 50) + ")");

            const innerRadius = Math.min(width, height) * .41,
                outerRadius = innerRadius * 1.1;

            const chord = d3.chord()
                .sortSubgroups(function(a, b) {
                    const label1 = data.nodes[a].name;
                    const label2 = data.nodes[b].name;
                    return label1.localeCompare(label2);
                })(data.matrix);

            // group
            const groupPathData = groupG
                .datum(chord)
                .selectAll("path.group")
                .data(function (d) {
                    return d.groups;
                });

            groupPathData.enter()
                .append("path")
                .attr("class", "group")
                .attr("d", d3.arc().innerRadius(innerRadius*10).outerRadius(outerRadius*10))
                .on("mouseover", fade(.1))
                .on("mouseout", fade(1));

            groupG.selectAll("path")
                .style("fill", function (d) {
                    const label = data.nodes[d.index].name;
                    return color(label);
                })
                .transition()
                .duration(duration)
                .attr("d", d3.arc().innerRadius(innerRadius).outerRadius(outerRadius));

            groupPathData.exit().remove();

            // ticks
            const tickGroupsData = tickG
                .datum(chord)
                .selectAll("g.tickGroup")
                .data(function (d) {
                    return d.groups;
                });

            tickGroupsData.enter()
                .append("g")
                .attr("class", "tickGroup");

            const tickGroupsAll = tickG.selectAll("g.tickGroup");

            tickGroupsData.exit().remove();

            const ticksData = tickGroupsAll.selectAll("g.tick")
                .data(groupTicks);

            const ticksEnter = ticksData.enter()
                .append("g")
                .attr("class", "tick");

            tickGroupsAll.selectAll("g.tick")
                .transition()
                .duration(duration)
                .attr("transform", function(d) {
                    return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
                        + "translate(" + outerRadius + ",0)";
                });

            ticksEnter.append("line")
                .attr("x1", 1)
                .attr("y1", 0)
                .attr("x2", 5)
                .attr("y2", 0)
                .style("stroke", "#000");

            ticksEnter.append("text")
                .attr("x", 8)
                .attr("dy", ".35em")
                .attr("transform", function(d) {
                    return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
                })
                .style("text-anchor", function(d) {
                    return d.angle > Math.PI ? "end" : null;
                })
                .text(function(d) {
                    return d.label;
                });

            ticksData.exit().remove();

            // chords
            const chordData = chordG
                .datum(chord)
                .selectAll("path")
                .data(function (d) {
                    return d;
                });

            chordData.enter()
                .append("path")
                .attr("d", d3.ribbon().radius(innerRadius/10))

            chordG.selectAll("path")
                .transition()
                .duration(duration)
                .attr("d", d3.ribbon().radius(innerRadius));

            chordData.exit().remove();

            function fade(opacity) {
                return function(g, i) {
                    svgG.selectAll(".chord path")
                        .filter(function(d) {
                            return d.source.index != i && d.target.index != i;
                        })
                        .transition()
                        .style("opacity", opacity);
                };
            }

            function groupTicks(d) {
                const k = (d.endAngle - d.startAngle) / d.value;
                const range = d3.range(0, d.value, 1000);
                let gt;
                if(range.length > 0) {
                    gt = d3.range(0, d.value, 10).map(function(v, i) {
                        const label = i == 0 ? data.nodes[d.index].name : v + "";
                        return {
                            angle: v * k + d.startAngle,
                            label: label
                        };
                    });
                }
                else {
                    gt = [{
                        angle: d.startAngle,
                        label: data.nodes[d.index].name
                    }]
                }
                return gt;
            }
        }

        d3.json("pactMatrix-both.json").then(function (bothMatrix) {
            d3.json("pactMatrix-sync.json").then(function (syncMatrix) {
                d3.json("pactMatrix-async.json").then(function (asyncMatrix) {
                    d3.csv("teams.csv").then(function (teams) {
                        console.log(bothMatrix)
                        reset();
                        redrawChord(bothMatrix, 1000);
                        ___();
                    })
                })
            })
        })

    })()
</script>