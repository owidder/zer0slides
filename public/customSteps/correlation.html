<style>

    #__0__ .label {
        font-size: 1em;
        fill: black;
        text-anchor: end;
    }

    #__0__ .regression {
        stroke-width: 3px;
        stroke-dasharray: 3;
    }
</style>

<div class="graph">

</div>

<script>

    (function () {
        const d3 = _0.d3;
        const _ = _0._;

        const width = window.innerWidth;
        const height = window.innerHeight;
        const MARGIN_X = 100;
        const MARGIN_Y = 100;
        const leftX = MARGIN_X;
        const rightX = width - MARGIN_X;
        const upperY = MARGIN_Y;
        const lowerY = height - MARGIN_Y;

        const svg = d3.select("#__0__ .graph").append("svg")
            .attr("width", width)
            .attr("height", height);

        const plotG = svg.append("g");
        const meanG = svg.append("g");
        const linearRegressionG = svg.append("g");
        const axis = svg.append("g");

        function translate(x, y) {
            return "translate(" + x + "," + y + ")"
        }

        axis.append("g")
            .attr("class", "yaxis")
            .attr("transform", translate(MARGIN_X - 10, 0))
            .append("g")
            .attr("transform", translate(20, MARGIN_Y) + " rotate(-90)")
            .append("text")
            .attr("class", "label ylabel")

        axis.append("g")
            .attr("class", "xaxis")
            .attr("transform", translate(0, height - MARGIN_Y + 10))
            .append("g")
            .attr("transform", translate(width - MARGIN_X, -10))
            .append("text")
            .attr("class", "label xlabel")

        function project(array, attrName) {
            return array.map(function (element) {
                return element[attrName]
            })
        }

        function scale(data, attrName, rangeMin, rangeMax) {
            const min = _.minBy(data, attrName)[attrName];
            const max = _.maxBy(data, attrName)[attrName];
            return d3.scaleLinear().domain([min, max]).range([rangeMin, rangeMax]);
        }

        function unscale(data, attrName, domainMin, domainMax) {
            const min = _.minBy(data, attrName)[attrName];
            const max = _.maxBy(data, attrName)[attrName];
            return d3.scaleLinear().domain([domainMin, domainMax]).range([min, max]);
        }

        function color(meanX, meanY, x, y) {
            if((x > meanX && y > meanY) || (x < meanX && y < meanY)) {
                return "green";
            }
            return "red";
        }

        function drawMeanLine(name, startX1, startX2, startY1, startY2, endX1, endX2, endY1, endY2) {
            meanG.selectAll("line.mean" + name).data([1]).enter()
                .append("line")
                .attr("class", "mean" + name)
                .attr("x1", startX1)
                .attr("x2", startX2)
                .attr("y1", startY1)
                .attr("y2", startY2)
                .attr("stroke", "grey")
                .attr("stroke-dasharray", 4)

            meanG.selectAll("line.mean" + name)
                .transition()
                .duration(2000)
                .attr("x1", endX1)
                .attr("x2", endX2)
                .attr("y1", endY1)
                .attr("y2", endY2)
        }

        function randomOutside(max) {
            return _.random(0, max) + Math.sign(_.random(-1000, 1000, true)) * max;
        }

        function drawLinearRegressionLine(plotData, xScale, yScale) {
            const xValues = project(plotData, "x");
            const yValues = project(plotData, "y");
            const allMax = _.max(_.union(xValues, yValues));
            const normalizer = d3.scaleLinear().domain([0, allMax]).range([0, 1]);
            const deNormalizer = d3.scaleLinear().domain([0, 1]).range([0, allMax]);
            const normalizedXValues = xValues.map(normalizer);
            const normalizedYValues = yValues.map(normalizer);

            const linearRegressionObject = ss.linearRegression([normalizedXValues, normalizedYValues]);
            const linearRegressionLineFunction = ss.linearRegressionLine(linearRegressionObject);

            const normalizedLeftX = normalizer(_.min(xValues));
            const normalizedLeftY = linearRegressionLineFunction(normalizedLeftX);
            const normalizedRightX = normalizer(_.max(xValues))
            const normalizedRightY = linearRegressionLineFunction(normalizedRightX);
            const normalizedMidX = normalizer(_.mean(xValues));
            const normalizedMidY = linearRegressionLineFunction(normalizedMidX);

            const leftX = deNormalizer(normalizedLeftX);
            const leftY = deNormalizer(normalizedLeftY);
            const rightX = deNormalizer(normalizedRightX);
            const rightY = deNormalizer(normalizedRightY);
            const midX = deNormalizer(normalizedMidX);
            const midY = deNormalizer(normalizedMidY);

            const linearRegressionLinePath = d3.line()([[xScale(leftX), yScale(leftY)], [xScale(rightX), yScale(rightY)]]);
            const startLinePath = d3.line()([[xScale(leftX), yScale(midY)], [xScale(rightX), yScale(midY)]]);

            linearRegressionG.selectAll("path.regression").data([1]).enter()
                .append("path")
                .attr("class", "regression")
                .attr("stroke", "black")
                .attr("d", startLinePath)

            linearRegressionG.selectAll("path.regression")
                .transition()
                .duration(1000)
                .attr("d", linearRegressionLinePath)
        }

        function draw(plotData, name1, name2) {
            const xScale = scale(plotData, "x", leftX, rightX);
            const yScale = scale(plotData, "y", lowerY, upperY);

            const meanX = _.meanBy(plotData, "x");
            const meanY = _.meanBy(plotData, "y");

            drawMeanLine("x", leftX-width, rightX-width, yScale(meanY), yScale(meanY), leftX, rightX, yScale(meanY), yScale(meanY));
            drawMeanLine("y", xScale(meanX), xScale(meanX), upperY-height, lowerY-height, xScale(meanX), xScale(meanX), upperY, lowerY);

            drawLinearRegressionLine(plotData, xScale, yScale);

            axis.transition().duration(1000).selectAll(".xaxis").call(d3.axisBottom(xScale));
            axis.transition().duration(1000).selectAll(".yaxis").call(d3.axisLeft(yScale));
            axis.select(".xlabel").text(name1);
            axis.select(".ylabel").text(name2);

            const data = plotG.selectAll("circle.dot").data(plotData);

            plotG.selectAll("title.dot").data(plotData);

            data.enter()
                .append("circle")
                .attr("class", "dot")
                .attr("r", 3)
                .attr("cx", function() {return randomOutside(width)})
                .attr("cy", function() {return randomOutside(height)})
                .append("title")
                .attr("class", "dot")

            plotG.selectAll("title.dot")
                .text(function(d) {return "[" + d.date + "] " + name1 + ": " + d.x + " / " + name2 + ": " + d.y})

            plotG.selectAll("circle.dot")
                .transition()
                .duration(function() {return _.random(1000, 2000)})
                .attr("cx", function (d) {
                    return xScale(d.x);
                })
                .attr("cy", function (d) {
                    return yScale(d.y);
                })
                .attr("fill", function (d) {
                    return color(meanX, meanY, d.x, d.y)
                })

            data.exit().remove();
        }

        function closeValueForDate(data, date) {
            return data.find(function(d) {return d.Date == date}).Close;
        }

        var currentName1, currentName2;
        function draw2DataSets(name1, name2) {
            currentName1 = name1;
            currentName2 = name2;
            return new Promise(function(resolve) {
                d3.csv("./csv/" + name1 + ".csv").then(function (data1) {
                    d3.csv("./csv/" + name2 + ".csv").then(function (data2) {
                        const dates1 = project(data1, "Date");
                        const dates2 = project(data2, "Date");
                        const commonDates = _.intersection(dates1, dates2);

                        const plotData = commonDates.map(function(date, i) {
                            const xValue = closeValueForDate(data1, date);
                            const yValue = closeValueForDate(data2, date);
                            return {
                                date: date,
                                x: Number(xValue),
                                y: Number(yValue),
                                id: i
                            }
                        })

                        console.log("draw " + name1 + "-" + name2);
                        draw(plotData, name1, name2);

                        resolve();
                    })
                })
            })
        }

        function changeDataStep(name1, name2) {
            let oldName1;
            let oldName2;

            return _0.step(
                function() {
                    oldName1 = currentName1;
                    oldName2 = currentName2;
                    return draw2DataSets(name1, name2);
                },
                function () {
                    return draw2DataSets(oldName1, oldName2);
                }
            )
        }

        draw2DataSets("Apple", "Facebook").then(function() {
            _0.addStep(changeDataStep("Bitcoin", "Ethereum"));
            _0.addStep(changeDataStep("Apple", "Microsoft"));
            _0.addStep(changeDataStep("Facebook", "Bitcoin"));
            _0.addStep(changeDataStep("Apple", "HewlettPackard"));
            _0.addStep(changeDataStep("Bitcoin", "HewlettPackard"));
            _0.addStep(changeDataStep("Ethereum", "HewlettPackard"));
        })

        ___();
    })()

</script>